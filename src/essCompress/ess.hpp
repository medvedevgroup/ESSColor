// UST
// Last Edited: May 20, 2020


#include <assert.h>
#include <stdint.h>
#include <unistd.h>
#include <cmath>
#include <cstring>
#include <fstream>
#include <iostream>
#include <vector>
#include <unordered_set>
#include <map>
#include <set>
#include <sstream>
#include <algorithm>
#include <cstdlib>
#include <list>
#include <stack>
#include <unordered_map>
#include <utility>
#include <queue>
#include <deque>
#include <tuple>

#include "stat.hpp"
#include "param.hpp"
#include "spss.hpp" //misc.hpp included
#include "decoder.hpp"

#define NONDNA_PLUS "a"
#define NONDNA_MINUS "c"
#define NONDNA_START 'g'
#define NONDNA_END 't'

// #define NONDNA_PLUS "+"
// #define NONDNA_MINUS "-"
// #define NONDNA_START '['
// #define NONDNA_END ']'

using namespace std;

inline string pref(const string &b, size_t kmersize)
{
    return b.substr(0, (kmersize - 1));
}
inline string cutPref(const string &b, size_t kmersize)
{
    //    if(b.length()<kmersize){
    //        return "";
    //    }
    return b.substr(kmersize - 1, b.length() - (kmersize - 1));
}
inline string suf(const string &b, size_t kmersize)
{
    //    if(b.length()<kmersize){
    //        return "";
    //    }
    return b.substr(b.length() - (kmersize - 1), (kmersize - 1));
}
inline string cutSuf(const string &b, size_t kmersize)
{
    //    if(b.length()<kmersize){
    //        return "";
    //    }
    return b.substr(0, b.length() - (kmersize - 1));
}

class ESS : public SPSS{
    
protected:
    typedef struct {
        unitig_t pos_in_walk = -100;
        unitig_t finalWalkId = -1; // renders some walkId as invalid
        unitig_t sccid = -1;
    } new_node_info_t;
    ESS::new_node_info_t* oldToNew;
    
    unitig_t &V_bcalm = stat.V_bcalm;
    
    typedef tuple<unitig_t,unitig_t,unitig_t> threetuple; // uid, walkid, pos
    vector<threetuple> sorter;
    bool static sort_by_walkId (const threetuple &lhs, const threetuple &rhs){
        return get<1>(lhs) < get<1>(rhs);
    }
    bool static sort_by_pos (const threetuple &lhs, const threetuple &rhs){
        return get<2>(lhs) < get<2>(rhs);
    }
    
    ESSStat stat;
    ESSParam param;
    
    unitig_t countNewNode = 0; // number of paths in initial phase
    
    vector<bool> obsoleteWalkId;

    void collectInput(int argc, char** argv, string & graph_file_name, int & K, bool & FLG_ABUNDANCE);
    void readUnitigFile(const string& unitigFileName, vector<unitig_struct_t>& unitigs, vector<vector<edge_t> >& adjList);
    vector<threetuple> sorterMaker();

public:
    //void run(int argc, char** argv, bool runFlag);
    ~ESS();
};


void ESS::readUnitigFile(const string& unitigFileName, vector<unitig_struct_t>& unitigs, vector<vector<edge_t> >& adjList)
{
    //bcalm_file_type = 0
    
    ifstream unitigFile;
    if(!unitigFile.good()){
        fprintf(stderr, "Error: File named \"%s\" cannot be opened.\n", unitigFileName.c_str());
        exit(EXIT_FAILURE);
    }
    
    unitigFile.open(unitigFileName);
    string line;
    
    unitig_t nodeNum;
    char lnline[20];
    char kcline[20];
    char kmline[20];
    char edgesline[100000];
    bool doCont = false;
    
    FLG_ABUNDANCE = false;
    bool USE_GGCAT = true;
    int smallestK = 9999999;
    //                if(!abundanceFlgDetermine){
    //                    if(  line.find("KC") == string::npos){ //no ab exists
    //                        ASSERT(line.find("ab") != string::npos, "Input bcalm file format is not compatible! Make sure you use the file ending with unitigs.fa generated by bcalm (check version)."<<"\n");
    //                        FLG_ABUNDANCE = true;
    //                        cout<<"Incorrect input format."<<endl;
    //                        exit(3);
    //                    }
    //                    abundanceFlgDetermine = true;
    //                }
    {
            getline(unitigFile, line);
            do {
                unitig_struct_t unitig_struct;
                
                if(FLG_ABUNDANCE){
                    //>3 LN:i:24 ab:Z:10 10 10 10 10 7 7 7 7 7 3 3 3 3   L:-:0:+ L:-:1:+  L:+:0:-
                    edgesline[0] = '\0';
                    sscanf(line.c_str(), "%*c %d %s", &unitig_struct.serial, lnline);
                    
                    if(    line.find("ab:Z") == string::npos){
                        cout<<"Incorrect input format. Check that input file matches the format of example cdbg."<<endl;
                        exit(3);
                    }
                    
                    sscanf(lnline, "%*5c %llu", &unitig_struct.ln);
                    
                    int abpos = line.find("ab") + 5;
                    int Lpos = line.find("L:");
                    
                    if(Lpos < 0){
                        Lpos = line.length() ;
                    }
                    // initialize string stream
                    //cout<<line.substr(abpos, Lpos - abpos);
                    stringstream ss(line.substr(abpos, Lpos - abpos));
                    string abun;
                    
                    sscanf(line.substr(Lpos, line.length() - Lpos).c_str(), "%[^\n]s", edgesline);
                    
                    if(unitig_struct.ln < smallestK){
                        smallestK = unitig_struct.ln ;
                    }
                    if(unitig_struct.ln < K){
                        printf("Wrong k! Try again with correct k value. \n");
                        exit(2);
                    }
                    
                }else if(USE_GGCAT){
                        edgesline[0] = '\0';
//                        sscanf(line.c_str(), "%*c %d %s  %s  %s %[^\n]s", &unitig_struct.serial, lnline, kcline, kmline, edgesline);
                        sscanf(line.c_str(), "%*c %d  %s %[^\n]s", &unitig_struct.serial, lnline, edgesline);
                        
                        //if(    line.find("L:") == string::npos){
                          //  cout<<"Incorrect input format. Try using flag -a 1."<<endl;
                          //  exit(3);
                       // }
                        
                        //>0 LN:i:13 KC:i:12 km:f:1.3  L:-:0:- L:-:2:-  L:+:0:+ L:+:1:-
                        sscanf(lnline, "%*5c %llu", &unitig_struct.ln);
                        
                        
                        if(unitig_struct.ln < smallestK){
                            smallestK = unitig_struct.ln ;
                        }
                        if(unitig_struct.ln < K){
                            printf("Wrong k! Try again with correct k value. \n");
                            exit(2);
                        }
                    }else{
                    edgesline[0] = '\0';
                    sscanf(line.c_str(), "%*c %d %s  %s  %s %[^\n]s", &unitig_struct.serial, lnline, kcline, kmline, edgesline);
                    
                    if(    line.find("KC") == string::npos){
                        cout<<"Incorrect input format. Check that input file matches the format of example cdbg."<<endl;
                        exit(3);
                    }
                    
                    //>0 LN:i:13 KC:i:12 km:f:1.3  L:-:0:- L:-:2:-  L:+:0:+ L:+:1:-
                    sscanf(lnline, "%*5c %llu", &unitig_struct.ln);
                    
                    
                    if(unitig_struct.ln < smallestK){
                        smallestK = unitig_struct.ln ;
                    }
                    if(unitig_struct.ln < K){
                        printf("Wrong k! Try again with correct k value. \n");
                        exit(2);
                    }
                }
                
                char c1, c2;
                stringstream ss(edgesline);
                
                vector<edge_t> edges;
                while (getline(ss, line, ' ')) {
                    if (delSpaces(line).length() != 0) {
                        if(DBGFLAG==VERIFYINPUT){
                            cout<<line<<endl;
                        }
                        
                        sscanf(line.c_str(), "%*2c %c %*c %d  %*c  %c", &c1, &nodeNum, &c2); //L:-:0:-
                        edge_t newEdge;
                        
                        bool DELSELFLOOP=true;
                        if(DELSELFLOOP){
                            if((unitig_struct.serial)!= nodeNum){
                                newEdge.left = charToBool(c1);
                                newEdge.right = charToBool(c2);
                                newEdge.toNode = nodeNum;
                                edges.push_back(newEdge);
                            }
                        }else{
                            newEdge.left = charToBool(c1);
                            newEdge.right = charToBool(c2);
                            newEdge.toNode = nodeNum;
                            edges.push_back(newEdge);
                        }
                    }
                }
                adjList.push_back(edges);
                
                doCont = false;
                while (getline(unitigFile, line)) {
                    if (line.substr(0, 1).compare(">")) {
                        //unitig_struct.sequence = unitig_struct.sequence + line;
                        unitigs.push_back(unitig_struct);
                    } else {
                        doCont = true;
                        break;
                    }
                }
            } while (doCont);
            unitigFile.close();
    }
    
    
    // if(smallestK > K ){
    //     cout<<"\n :::: :::: :::: :::: !!!!!!!!! WARNING !!!!!!!!!!! :::: :::: :::: ::::"<<endl;
    //     cout<<"The length of the smallest string we found was " << smallestK << ". Please make sure you are using the correct value of 'k' to ensure correctness of output."<<endl;
    //     cout << "------------------------------------------------------"<<endl;
    // }
    
    param.UNITIG_FILE = unitigFileName;
    //cout << "Complete reading input unitig file (bcalm2 file)." << endl;
}


vector<ESS::threetuple> ESS::sorterMaker() {
    bool* saturated = new bool[V_bcalm];
    char* color = new char[V_bcalm];
    unitig_t * p_dfs = new unitig_t[V_bcalm];
    vector<list<unitig_t> > newToOld;
    
    double time_a = readTimer();
    
    for (unitig_t i = 0; i < V_bcalm; i++) {
        color[i] = 'w';
        p_dfs[i] = -1;
        saturated[i] = false;
    }
    
    //cout<<"Basic V loop time: "<<readTimer() - time_a<<" sec"<<endl;
    time_a = readTimer();
    
    for (unitig_t j = 0; j < V_bcalm; j++) {
        unitig_t u;
        
        if(0==1){
            u = sortStruct[j].node;
        }else{
            u = j;
        }
        
        if (color[u] == 'w') {  //DFS_visit(u)
             stack<edge_t> s;
            edge_t uEdge;
            uEdge.toNode = u;
            s.push(uEdge);
            
            while (!s.empty()) {
                edge_t xEdge = s.top();
                
                unitig_t x = xEdge.toNode;
                s.pop();
                
                if (color[x] == 'w') {
                    color[x] = 'g';
                    s.push(xEdge);
                    vector<edge_t> adjx = adjList.at(x);
                    
                    // Now our branching code ::
                    // For a white x
                    // Consider 2 case:
                    // Case 1. p[x] = -1, it can happen in two way, x is the first one ever in this connected component, or no one wanted to take x
                    // either way, if p[x] = -1, i can be representative of a new node in new graph
                    // Case 2. p[x] != -1, so x won't be the representative/head of a newHome. x just gets added to its parent's newHome.
                    unitig_t u = unitigs.at(x).ln; //unitig length
                    assert(u >= K);
                    
                    if (p_dfs[x] == -1) {
                        list<unitig_t> xxx;
                        xxx.push_back(x);
                        newToOld.push_back(xxx);
                        oldToNew[x].finalWalkId = countNewNode++; // countNewNode starts at 0, then keeps increasing
                        oldToNew[x].pos_in_walk = 1;
                    } else {
                        newToOld[oldToNew[p_dfs[x]].finalWalkId].push_back(x);
                        oldToNew[x].finalWalkId = oldToNew[p_dfs[x]].finalWalkId;
                        
                        { //ALGOMODE==TWOWAYEXT || ALGOMODE==BRACKETCOMP
                            disSet.Union(x, p_dfs[x]);
                        }
                        
                        oldToNew[x].pos_in_walk = oldToNew[p_dfs[x]].pos_in_walk + 1;
                    }
                    
                    // x->y is the edge, x is the parent we are extending
                    for (edge_t yEdge : adjx) { //edge_t yEdge = adjx.at(i);
                        unitig_t y = yEdge.toNode;
                        
//                        if(ALGOMODE == BRACKETCOMP){
//                            if(global_issinksource[y] == true){
//                                continue;
//                            }
//                        }
                        
                        if (color[y] == 'w') { //Normal DFS
                            s.push(yEdge);
                        }
                        
                        if (y == x) { // self-loop
                            cout<<"FAIL: should not have self-loop."<<endl;
                            assert(false);
                            edge_both_t e;
                            e.edge = yEdge;
                            e.fromNode = x;
                        } else if (saturated[x]) {
                            // Since x is saturated, we only add resolveLater edges
                            // no need to check for consistency
                            if (y != p_dfs[x]) {
                                edge_both_t e;
                                e.edge = yEdge;
                                e.fromNode = x;
                            }
                        } else {
                            // If x has space to take a child, meaning x is not saturated
                            // hunting for potential child
                            
                            if (color[y] == 'w' && p_dfs[y] == -1) {
                                // y has white color & got no parent => means it's homeless, so let's see if we can take it as a child of x
                                //But just see if it is eligible to be a child, i.e. is it consistent (sign check)?
                                
                                //2 case, Does x's child have grandparent?
                                // If No:
                                if (p_dfs[x] == -1) {
                                    // case 1: child has no grandparent
                                    // so extend path without checking any sign
                                    nodeSign[x] = yEdge.left;
                                    nodeSign[y] = yEdge.right;
                                    p_dfs[y] = x;
                                    saturated[x] = true; //found a child
                                    
                                } else if (nodeSign[x] == yEdge.left) {
                                    // case 2: child (=y) has grandparent, i.e. x's parent exists
                                    nodeSign[y] = yEdge.right;
                                    p_dfs[y] = x;
                                    saturated[x] = true; //found a child
                                    
                                } else {
                                    // do we reach this case?
                                    edge_both_t e;
                                    e.edge = yEdge;
                                    e.fromNode = x;
                                }
                                
                            } else {
                                //merger
                                {
                                    // y is not white
                                    bool consistentEdge = (nodeSign[y] == yEdge.right && (p_dfs[x]==-1 || (p_dfs[x]!=-1&& nodeSign[x] == yEdge.left)) );
                                    if(p_dfs[y]==-1 && consistentEdge && oldToNew[x].finalWalkId != oldToNew[y].finalWalkId){
                                        
                                        //cout<<"x: "<<x<<":" <<disSet.find_set(x)<<" ";
                                        //cout<<"y: "<<y<<":" <<disSet.find_set(y) <<endl;
                                        
                                        //not in same group already, prevent cycle
                                        if(disSet.find_set(x)!=disSet.find_set(y)){
                                            nodeSign[x] = yEdge.left;
                                            nodeSign[y] = yEdge.right;
                                            p_dfs[y] = x;
                                            saturated[x] = true; //found a child
                                            // oldToNew[y].serial
                                            
                                            disSet.Union(x, y);
                                            gmerge.connectGroups(oldToNew[x].finalWalkId,oldToNew[y].finalWalkId );
                                            
                                        }
                                    }
                                }
                                
                                if (y != p_dfs[x]) {
                                    edge_both_t e;
                                    e.edge = yEdge;
                                    e.fromNode = x;
                                }
                            }
                        }
                    }
                } else if (color[x] == 'g') {
                    color[x] = 'b';
                }
            }
        }
    }
    delete [] color;
    delete [] p_dfs;
    delete [] saturated;
    if(param.VERBOSE_MODE) cout<<"Done. DFS time: "<<readTimer() - time_a<<" sec"<<endl;
    
    
    /***MERGE START***/
    bool* merged = new bool[countNewNode];  // now we will do union-find with path compresison for both way merge
    
    //obsoleteWalkId = new bool[countNewNode];
    
    for (unitig_t i = 0; i<countNewNode; i++) {
        merged[i] = false;
        obsoleteWalkId.push_back(false);
        //obsoleteWalkId[i] = false;
    }
    
    { //both way merging
        for ( const auto& p: gmerge.fwdWalkId)
        {
            if(gmerge.fwdVisited[p.first] == false){
                unitig_t fromnode =p.first;
                unitig_t tonode = p.second;
                deque<unitig_t> lst;
                
                lst.push_back(fromnode);
                lst.push_back(tonode);
                
                gmerge.fwdVisited[fromnode] = true;
                gmerge.bwdVisited[tonode] = true;
                
                if(gmerge.fwdVisited.count(tonode)>0){
                    while(gmerge.fwdVisited[tonode] == false){
                        gmerge.fwdVisited[tonode] = true;
                        tonode = gmerge.fwdWalkId[tonode];
                        gmerge.bwdVisited[tonode] = true;
                        
                        lst.push_back(tonode);
                        if(gmerge.fwdVisited.count(tonode)==0)
                            break;
                    }
                }
                if(gmerge.bwdVisited.count(fromnode)>0){
                    while(gmerge.bwdVisited[fromnode] == false){
                        gmerge.bwdVisited[fromnode] = true;
                        fromnode = gmerge.bwdWalkId[fromnode];
                        gmerge.fwdVisited[fromnode] = true;
                        
                        lst.push_front(fromnode);
                        if(gmerge.bwdVisited.count(fromnode)==0)
                            break;
                    }
                }
                
                assert(!lst.empty());
                unitig_t commonWalkId = lst.at(0);
                unitig_t posOffset = 1;
                
                for(auto i: lst){
                    // i is new walk id before merging
                    merged[i] = true;
                    
                    //POTENTIAL BUG @BRACKETCOMP
                    if(i!=commonWalkId){
                        obsoleteWalkId[i] = true;
                    }
                    
                    // travesing the walk list of walk ID i
                    for(unitig_t uid: newToOld[i]){
                        oldToNew[uid].finalWalkId = commonWalkId;
                        oldToNew[uid].pos_in_walk = posOffset++;
                    }
                }
                
                stat.V_ust++;
            }
        }
        
        for (unitig_t newNodeNum = 0; newNodeNum<countNewNode; newNodeNum++){
            if(merged[newNodeNum] == false){
                
                stat.V_ust++;
            }
        }
        delete [] merged;
        vector<list<unitig_t> >().swap(newToOld);
    }
    
    //sorter of all walks and printing them
    vector<threetuple> sorter;
    for(unitig_t uid = 0 ; uid< V_bcalm; uid++){
        new_node_info_t nd = oldToNew[uid];
        sorter.push_back(make_tuple(uid, nd.finalWalkId, nd.pos_in_walk));
    }
    
    stable_sort(sorter.begin(),sorter.end(),sort_by_pos);
    stable_sort(sorter.begin(),sorter.end(),sort_by_walkId);
    
//    //@@@@@ BRACKETED
//    reassign(obsoleteWalkId);
//    delete [] obsoleteWalkId;
    return sorter;
}




ESS::~ESS(){
    delete [] nodeSign;
    delete [] oldToNew;
    delete [] sortStruct;
    //delete [] obsoleteWalkId;
}





class SCCGraph
{
public:
    unitig_t V;    // No. of vertices
    vector<unitig_t> *adj;    // An array of adjacency lists
    SCCGraph(unitig_t V);
    SCCGraph();
    void addEdge(unitig_t v, unitig_t w);
    void findTarjanSCC(unitig_t& countSCC, map<unitig_t, unitig_t>& vToMetagraphV, vector<bool>& obsoleteWalkId, map<unitig_t, set<unitig_t> >& sccIdToWalks);
    ~SCCGraph(){
        delete [] adj;
    }
};


class AbsorbGraph : public ESS
{
public:
    vector<threetuple> sorter;
    map<unitig_t, unitig_t > sorterIndexMap;
    map<unitig_t, vector<unitig_t> > ccAdjList;
    vector<unitig_t> earliestAbsorberPos;
    map<unitig_t, vector<edge_t> > absorbGraph;
    map<unitig_t, stack<edge_t> > absorbGraphCycleRemoved;

    //early absorb stuff
    //bool EARLYABSORB = true;

    SCCGraph* g;
    bool* absorbed;
    char* absorbedCategory;

    queue<unitig_t> orderOfUnitigs;
    queue<unitig_t> reservedStringSize;

    queue<unitig_t> printSCCs();

    /*helpers*/
    /*string*/
    string splitA(string &s, int);
    string splitX(string &s, int);
    string splitB(string &s, int);

    bool isItWalkStarting(unitig_t uid);
    vector<unitig_t> getAllUidsInWalk(unitig_t walkId);

    
    void absorptionManager();
    
    void lowerboundcc();
    void earlyAbsorb(const vector<unitig_t>&, bool*);
    

    void sorterIndexAndAbsorbGraphMaker();    //make the absorb graph with cycle, populates sorterIndexMap AND absorbGraph

    void absorbGraphIsCyclicUtil(unitig_t uid, vector<char>& visited, int depth);
    void removeCycleFromAbsorbGraph();
    void iterSpellEfficient(unitig_t startWalkIndex2, vector<char>& color, ofstream& nostrfile);
    
//    bool* isItAPrintedWalk;
    
    void tipAbsorbedOutputter();

    void printFormattedPattern(unitig_t uid, char preOrSuf, ofstream &FOUT);
    void splitToFourPartNodeSign();
    
    void run(string graph_file_name, int K, bool runFlag = 0);
    
    
    /*unnecessary*/
    void makeGraphDotAbsorb(map<unitig_t, vector<edge_t> > adjList);
    
    ofstream cp;
    ofstream cP;
    ofstream cs;
    ofstream cS;
    ofstream cx;
    
    AbsorbGraph(){
    }
    

    ~AbsorbGraph(){
        
            delete [] absorbedCategory;
            delete [] absorbed;
            //delete [] isItAPrintedWalk;
        
    }
};



void AbsorbGraph::run(string graph_file_name, int K, bool runFlag){
    param.VERBOSE_MODE = runFlag;
    if(param.VERBOSE_MODE) cout<<"Running ESS-Compress (core) "<<endl;
    
    this->K = K;
    param.UNITIG_FILE = graph_file_name;
    //collectInput(argc, argv, graph_file_name, K, FLG_ABUNDANCE); //input: argc, argv
    
    if(param.VERBOSE_MODE) cout << "[1] Input file is being loaded.... " << graph_file_name << ": k = "<<K<<endl;
    double startTime = readTimer();
    
    this->readUnitigFile(param.UNITIG_FILE, unitigs, adjList); //input: graph_filename, output: last 2
    
    double TIME_READ_SEC = readTimer() - startTime;
    //cout<<".........................."<<endl;
    if(param.VERBOSE_MODE) cout<<"Done. TIME to read file "<<TIME_READ_SEC<<" sec."<<endl;
    
    //initialization phase
    param.OUTPUT_FILENAME = "kmers.ess";
    globalStatFile.open("stat_ess.txt", std::fstream::out);

    V_bcalm = adjList.size();
    nodeSign = new bool[V_bcalm];
    oldToNew = new new_node_info_t[V_bcalm];
    sortStruct = new struct node_sorter[V_bcalm];
    
    for (unitig_t i = 0; i < V_bcalm; i++) {
        nodeSign[i] = false;
        disSet.make_set(i);
        oldToNew[i].finalWalkId = -1;
        sortStruct[i].sortkey = 0;
        sortStruct[i].node = i;
    }
    
    //stat collector
    stat.E_bcalm = 0;
    for (unitig_t i = 0; i < V_bcalm; i++) { //count total number of edges
        stat.E_bcalm += adjList[i].size();
    }
    
    stat.nKmers = 0;
    stat.C_bcalm = 0;
    for (unitig_struct_t unitig : unitigs) {    //count total number of kmers and characters
        stat.C_bcalm += unitig.ln;
        stat.nKmers +=  unitig.ln - K + 1;
    }
    
    stat.V_bcalm = V_bcalm;
    
    stat.statPrinter(globalStatFile, "K", K);
    stat.statPrinter(globalStatFile, "N_KMER", stat.nKmers);
    stat.statPrinter(globalStatFile, "V_BCALM", stat.V_bcalm);
    stat.statPrinter(globalStatFile, "E_BCALM", stat.E_bcalm);
    stat.statPrinter(globalStatFile, "C_BCALM", stat.C_bcalm);
    
    
    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@//
    //##################################################//
    
    //DFS
    if(param.VERBOSE_MODE) cout<<"[2] DFS algorithm for stitching unitigs is running... "<<endl;
    sorter = this->sorterMaker();
    
    double time_a = readTimer();
    
    // if(runFlag==1){
    //     return;
    // }
    
    
    if(param.VERBOSE_MODE) cout<<"[3] Starting absorption module... "<<endl;
    this->absorptionManager();
    
    
    if(param.VERBOSE_MODE) cout<<"TIME to output: "<<readTimer() - time_a<<" sec."<<endl;
    double TIME_TOTAL_SEC = readTimer() - startTime;
    
    
    
   
    
    if(system(("cat "+param.OUTPUT_FILENAME+ "| grep -v \">\" | wc | awk '{print $3-$1}' > tmp.txt").c_str())!=0)  exit(3);
    ifstream tmpfile;
    tmpfile.open("tmp.txt");
    tmpfile >> stat.C_ess;
    tmpfile.close();
    if(system("rm -rf tmp.txt")!=0) exit(3);

    stat.statPrinter(globalStatFile, "C_ESS", stat.C_ess);
    stat.statPrinter(globalStatFile, "V_UST", stat.V_ess);

    stat.statPrinter(globalStatFile, "C_UST", stat.C_ess);
    stat.statPrinter(globalStatFile, "CHAR_PER_KMER_ESS", stat.C_ess*1.0/stat.nKmers);

    stat.statPrinter(globalStatFile, "TIME_TOTAL_SEC", TIME_TOTAL_SEC, false);
    if(param.VERBOSE_MODE) cout<<"Total time for ESS-Compress core: "<<TIME_TOTAL_SEC<<endl;

    uint64_t maxulen = maximumUnitigLength();
    stat.statPrinter(globalStatFile, "MAX_UNITIG_LEN_MB", maxulen*1.0/1024.0/1024.0);
    stat.statPrinter(globalStatFile, "E_MB", stat.E_bcalm*8.0/1024.0/1024.0);
    stat.statPrinter(globalStatFile, "V_MB", stat.V_bcalm*8.0/1024.0/1024.0);
    
    
    if(param.VERBOSE_MODE) cout << "------------ End of ESS-Compress (core) : Success" << " ------------"<<endl;
    cout << "Total number of unique "<<K<<"-mers " <<  "= " << stat.nKmers << endl;
    cout << "Size of ESS-Compress representation = "<< stat.C_ess*1.0/stat.nKmers <<" char/k-mer" << endl;
    
    
    if(param.VALIDATE){
        cout<<"## [4] Decoding ESS...\n";
        double decodetime = readTimer();
        decodeOneAbsorb(K,param.ofileTipOutput);
        decodetime = readTimer() - decodetime;
        stat.statPrinter(globalStatFile, "TIME_DECODE_SEC", decodetime, true);
        cout<<"[COMPLETE][4] Decoding done. TIME: "<<decodetime<<"sec. \n";
        cout << "------------------------------------------------------"<<endl;
        
        //validate();
        cout<<"## [5] Validating decoded ESS...\n";
        if(system((param.DSK_PATH +"dsk -file "+param.UNITIG_FILE+" -kmer-size "+to_string(K)+" -abundance-min 1 -out list_reads.unitigs.h5 -verbose 0").c_str())!=0) exit(3);
        if(system((param.DSK_PATH + "dsk -file absorbDecompressed.fa -kmer-size "+to_string(K)+" -abundance-min 1  -verbose 0").c_str())!=0) exit(3);
        if(system((param.DSK_PATH+"dsk2ascii -file list_reads.unitigs.h5 -out output-bcalm.txt  -verbose 0").c_str())!=0) exit(3);
        if(system((param.DSK_PATH + "dsk2ascii -file absorbDecompressed.h5 -out output-my.txt   -verbose 0").c_str())!=0) exit(3);
        //cout<<"doing highly  accurate validation................"<<endl;
        if(system("sort -k 1 -n output-bcalm.txt -o a.txt; sort -k 1 -n output-my.txt -o b.txt")!=0) exit(3);
        if(system("cmp a.txt b.txt && echo '### SUCCESS: Files Are Identical! ###' || echo '### WARNING: Files Are Different! ###'")!=0) exit(3);
        if(system("rm -rf a.txt b.txt output-bcalm.txt output-my.txt list_reads.unitigs.h5 absorbDecompressed.h5")!=0) exit(3);
    }
    
    globalStatFile.close();
}


string AbsorbGraph::splitA(string &s, int K){
    int ol = K-1;
    return s.substr(0, ol);
}
string AbsorbGraph::splitB(string &s, int K){
    int ol = K-1;
    int pref_end_index = ol - 1;
    size_t suf_start_index = s.length() - ol;
    if(pref_end_index >= suf_start_index){
        return cutPref(s, K);
        //return s.substr(pref_end_index+1, s.length()- pref_end_index - 1); //cutPref
    }
    return suf(s,K);
    //s.substr(suf_start_index, ol);
}

string AbsorbGraph::splitX(string &s, int K){
    int ol = K-1;
    int pref_end_index = ol - 1;
    size_t suf_start_index = s.length() - ol;
    string X = "";
    if(pref_end_index < suf_start_index){
        X = s.substr(pref_end_index+1,suf_start_index-pref_end_index-1);
        //X=cutPref(s, K);
        //X = cutSuf(X, K);
    }
    return X;
}

void AbsorbGraph::lowerboundcc(){
    bool* ccVisited =  new bool[countNewNode];
    for(unitig_t i = 0; i<countNewNode; i++){
        ccVisited[i] = false;
    }

    stack<unitig_t> stack;
    for(unitig_t ii=0;ii<countNewNode;ii++)
    {
        if(ccVisited[ii] == false &&  !obsoleteWalkId[ii])
        {
            //cout<<endl;
            stack.push(ii);
            //vector<int>nodes;
            //nodes.push_back(i);
            stat.absorbGraphNumCC_endAbosrb++;

            while (!stack.empty())
            {
                unitig_t s = stack.top();
                stack.pop();

                if (!ccVisited[s])
                {
                    //cout << s << " ";
                    ccVisited[s] = true;
                }

                // Get all adjacent vertices of the popped vertex s
                // If a adjacent has not been visited, then push it
                // to the stack.
                for (auto i = ccAdjList[s].begin(); i != ccAdjList[s].end(); ++i)
                    if (!ccVisited[*i])
                        stack.push(*i);
            }
            //cout<<"This component has "<<count<<" nodes"<<"\n";
            //          for(int nn:nodes){
            //              cout<<nn<<",";
            //          }
            //cout<<endl;
        }
    }
    cout<<"number of connected components (end): "<<stat.absorbGraphNumCC_endAbosrb<<endl;
    delete [] ccVisited;
}


void AbsorbGraph::earlyAbsorb(const vector<unitig_t>& earliestAbsorberPos,bool* isAnAbsorbedWalk){
    for(unitig_t wid=0; wid<countNewNode; wid++){
        //
        if(!isAnAbsorbedWalk[wid] && !obsoleteWalkId[wid]){
            //earliestAbsorberPos[wid];
            unitig_t it = sorterIndexMap[wid];
            for(unitig_t x = it+1; x<sorter.size(); x++){
                unitig_t walkId = get<1>(sorter[x]);
                unitig_t pos = get<2>(sorter[x]);
                unitig_t uid=get<0>(sorter[x]);
                if(walkId!=wid || pos >= earliestAbsorberPos[wid]){
                    break;
                }

                for(edge_t e : adjList[uid]){
                    unitig_t absorber_uid = e.toNode;
                    unitig_t absorberWalk = oldToNew[absorber_uid].finalWalkId;
                    unitig_t absorber_pos = oldToNew[absorber_uid].pos_in_walk;
                    if(!(absorber_pos<earliestAbsorberPos[absorberWalk]) && !isItWalkStarting(absorber_uid)){
                        //add it
                        if(absorberWalk != wid  ){
                            edge_t enew;
                            if(e.left==e.right){
                                enew.left = (e.left?false:true);
                                enew.right = (e.right?false:true);
                            }else{
                                enew.left = e.left;
                                enew.right = e.right;
                            }
                            enew.toNode = uid;
                            //                            bool is1 =(enew.left == nodeSign[e.toNode] && enew.right == nodeSign[enew.toNode] );
                            //                            bool is4 =(enew.left != nodeSign[e.toNode] && enew.right == nodeSign[enew.toNode] );
                            //                            bool is3 =(enew.left != nodeSign[e.toNode] && enew.right != nodeSign[enew.toNode] );
                            //                            bool is2 =(enew.left == nodeSign[e.toNode] && enew.right != nodeSign[enew.toNode] );

                            absorbGraph[e.toNode].push_back(enew);
                            isAnAbsorbedWalk[wid]=true;
                            g->addEdge(absorberWalk, wid);
                            if(param.GETLOWERBOUND_CC){
                                ccAdjList[absorberWalk].push_back(wid);
                                ccAdjList[wid].push_back(absorberWalk);
                            }
                        }
                    }
                }
            }
        }
    }
}

bool AbsorbGraph::isItWalkStarting(unitig_t uid){
    unitig_t pos_in_walk = oldToNew[uid].pos_in_walk;
    if(pos_in_walk > 1) return false;
    if(pos_in_walk == 0) return true;
    if(sorterIndexMap.count(oldToNew[uid].finalWalkId)==0){
        auto adjL = adjList[uid];
        for(edge_t ee: adjL){
            if(oldToNew[ee.toNode].pos_in_walk==0 && oldToNew[ee.toNode].finalWalkId == oldToNew[uid].finalWalkId ){
                return false;
            }
        }
        return true;
    }
    assert(!obsoleteWalkId[oldToNew[uid].finalWalkId]);
    assert(sorterIndexMap.count(oldToNew[uid].finalWalkId)>0);
    unitig_t it = sorterIndexMap[oldToNew[uid].finalWalkId];
    assert(it<sorter.size());
    unitig_t ituid = get<0>(sorter[it]);
    return (uid==ituid);
}


void AbsorbGraph::sorterIndexAndAbsorbGraphMaker(){
    if(DDEBUG==2){
        for(int i =0 ; i<sorter.size(); i++){
            int tup_i = i+1;
            unitig_t prev_uid = get<0>(sorter[tup_i - 1]);
            unitig_t prev_wid = get<1>(sorter[tup_i - 1]);
            unitig_t prev_pos = get<2>(sorter[tup_i - 1]);
            cout<<prev_uid<<" "<<prev_wid<<" "<<prev_pos<<endl;
        }
    }
    
    unitig_t prevWalkId = -1;
    unitig_t lastWalkStartingIndex = -1;

    bool* isAnAbsorbedWalk = new bool[countNewNode];
    for(unitig_t i = 0; i<countNewNode; i++){
        isAnAbsorbedWalk[i]=false;
    }

    unitig_t MAX_POS = V_bcalm+1;
    vector<unitig_t> earliestAbsorberPos(countNewNode, MAX_POS);

    for(unitig_t tup_i = 0; tup_i < sorter.size(); tup_i++){
        threetuple tup = sorter[tup_i];
        unitig_t uid = get<0>(tup);
        new_node_info_t nd = oldToNew[uid];
        unitig_t finalWalkId = get<1>(tup);

        
        //for end abosrbing
        if(prevWalkId !=finalWalkId ){  //walk starting: 2 cases-> a) this is not walk ender b) ender
            if(prevWalkId!=-1){
                unitig_t prev_uid = get<0>(sorter[tup_i - 1]);
                unitig_t prev_wid = get<1>(sorter[tup_i - 1]);
                unitig_t prev_pos = get<2>(sorter[tup_i - 1]);
                //earliestAbsorberPos[prev_wid] =2;
                //                if(prev_pos/2>1){
                //                    earliestAbsorberPos[prev_wid] =prev_pos/2;
                //                }else{
                //                    earliestAbsorberPos[prev_wid] = 2;
                //                }
            }

            lastWalkStartingIndex = tup_i;
            sorterIndexMap[finalWalkId] = lastWalkStartingIndex;

            auto adju = adjList.at(uid);
            for (edge_t e : adju) {

                unitig_t absorberWalk = oldToNew[e.toNode].finalWalkId;
                unitig_t absorbedWalk = nd.finalWalkId;


                if(absorberWalk != absorbedWalk){   // && isAnAbsorbedWalk[oldToNew[uid].finalWalkId] == false
                    assert(absorberWalk<countNewNode);
                    assert(absorbedWalk<countNewNode);

                    edge_t enew; //the edge "enew" is from absorber uid to absorbed uid
                    if(e.left==e.right){
                        enew.left = (e.left?false:true);
                        enew.right = (e.right?false:true);
                    }else{
                        enew.left = e.left;
                        enew.right = e.right;
                    }
                    enew.toNode = uid;

                    bool is1 =(enew.left == nodeSign[e.toNode] && enew.right == nodeSign[enew.toNode] );
                    bool is4 =(enew.left != nodeSign[e.toNode] && enew.right == nodeSign[enew.toNode] );
                    bool is3 =(enew.left != nodeSign[e.toNode] && enew.right != nodeSign[enew.toNode] );
                    bool is2 =(enew.left == nodeSign[e.toNode] && enew.right != nodeSign[enew.toNode] );
                    // || is1 || is2  || (unitigs.at(e.toNode).sequence.length() >= 2*(K-1))
                    if(!isItWalkStarting(e.toNode) || is1 || is2 || (unitigs.at(e.toNode).ln >= 2*(K-1))) {
                         //|| is1 || is2
                         if( is1 || is2 || is3 || is4){
                        //if( ((is1 or is4) or (!ABSORBONLYTWO)) ){
                            absorbGraph[e.toNode].push_back(enew);

                             if(param.EARLYABSORB){
                                 if(oldToNew[e.toNode].pos_in_walk < earliestAbsorberPos[absorberWalk]){
                                     earliestAbsorberPos[absorberWalk] =oldToNew[e.toNode].pos_in_walk ;
                                     assert(earliestAbsorberPos[absorberWalk]>0);
                                 }

                             }

                            isAnAbsorbedWalk[oldToNew[uid].finalWalkId]=true;
                            g->addEdge(absorberWalk, absorbedWalk);
                             if(param.GETLOWERBOUND_CC){
                                ccAdjList[absorberWalk].push_back(absorbedWalk);
                                ccAdjList[absorbedWalk].push_back(absorberWalk);
                            }
                        }
                    }
                }
            }
            
        }
        prevWalkId = finalWalkId;
    }
    
    if(param.EARLYABSORB){
        earlyAbsorb(earliestAbsorberPos, isAnAbsorbedWalk);
    }
        
    if(param.GETLOWERBOUND_CC){
        lowerboundcc();
    }
    
    vector<vector<edge_t> >().swap(adjList);
    delete [] isAnAbsorbedWalk;
    if(param.PROFILE_ONLY_ABS){
        ofstream globalStatFile("global_stat", std::fstream::out | std::fstream::app);
        globalStatFile << "ABSORB_GRAPH_NUM_CC" <<  "=" <<stat.absorbGraphNumCC_endAbosrb << endl;
        globalStatFile.close();
        return;
    }
}

vector<unitig_t> AbsorbGraph::getAllUidsInWalk(unitig_t walkId){  //not  tested
    vector<unitig_t> uids;
    unitig_t it = sorterIndexMap[walkId];
    for(unitig_t i=it; i<sorter.size(); i++){
        unitig_t wid = get<1>(sorter[i]);
        if(wid!=walkId){
            break;
        }

        unitig_t uid = get<0>(sorter[i]);
        uids.push_back(uid);
    }
    return uids;
}

void SCCGraph::findTarjanSCC(unitig_t& countSCC, map<unitig_t, unitig_t>& vToMetagraphV, vector<bool>& obsoleteWalkId, map<unitig_t, set<unitig_t> >& sccIdToWalks) //Tarjan's algorithm, iterative version.
{
    //cout<<"Running tarjan's iterative SCC algorithm...";
    unitig_t next = 0; // # Next index.
    unitig_t N = V;
    unitig_t NIL = -1;
    vector<unitig_t> index(N, NIL);
    vector<unitig_t> lowlink(N, NIL);
    vector<bool> onstack(N, false);
    stack<unitig_t> stak;
    unitig_t nextgroup = 0 ;
    vector<vector<unitig_t> > groups; // # SCCs: list of vertices.
    map<unitig_t, unitig_t>& groupid = vToMetagraphV; // # Map from vertex to SCC ID.
    
    for(unitig_t v = 0; v<N; v++){
        if (index[v] == NIL && !obsoleteWalkId[v]){
            //sconnect(v);
            stack<pair<unitig_t, unitig_t> > work;
            work.push(make_pair(v,0));//        = [(v, 0)] # NEW: Recursion stack.
            bool recurse = false;
            while (!work.empty()){
                v = work.top().first;
                unitig_t i = work.top().second; // i is next successor to process.
                work.pop();
                if (i == 0){ // When first visiting a vertex:
                    index[v] = next;
                    lowlink[v] = next;
                    next += 1;
                    stak.push(v);
                    onstack[v] = true;
                }
                recurse = false;
                
                for(unitig_t j = 0; j<adj[v].size(); j++)
                {
                    unitig_t w = adj[v][j];
                    if (index[w] == NIL)
                    {   work.push(make_pair(v, j+1));
                        work.push(make_pair(w, 0));
                        recurse = true;
                        break;
                    }
                    else if (onstack[w])
                    {
                        lowlink[v] = min(lowlink[v], index[w]);
                    }
                }
                if (recurse) continue ;
                if (index[v] == lowlink[v])
                {
                    vector<unitig_t> com;
                    while (true)
                    {
                        unitig_t w = stak.top();
                        stak.pop();
                        onstack[w] = false;
                        com.push_back(w);
                        groupid[w] = nextgroup ;
                        sccIdToWalks[nextgroup].insert(w);
                        if (w == v) break;
                    }
                    //cout<<endl;
                    groups.push_back(com);
                    nextgroup += 1;
                }
                if (!work.empty())
                {
                    unitig_t w = v;
                    v = work.top().first;
                    lowlink[v] = min(lowlink[v], lowlink[w]);
                }
            }
        }
    }
    countSCC = nextgroup;
    //cout<<nextgroup<<endl;
    //cout<<groups.size()<<endl;
}

void AbsorbGraph::removeCycleFromAbsorbGraph()
{
    char *visited = new char[countNewNode];
    unitig_t *parent= new unitig_t[V_bcalm];
    for(unitig_t i = 0; i < countNewNode; i++)
    {
        visited[i] = (obsoleteWalkId[i]?'b':'w');        // Initially mark all walks as not visited ('w') (except invalid walks)
    }
    for(unitig_t i = 0; i < V_bcalm; i++)
    {
        parent[i] = -1;
    }
    map<unitig_t, edge_t> edmap;
    stack<unitig_t> stak;

    vector<pair<unitig_t, unitig_t> > indegree(countNewNode, make_pair(0,0));
    vector<unitig_t> oldnode(countNewNode, 0);
    for(unitig_t i = 0; i< indegree.size(); i++){
        indegree[i] = make_pair(i, 0);
    }

    for (std::map<unitig_t, vector<edge_t> >::iterator it=absorbGraph.begin(); it!=absorbGraph.end(); ++it){
        unitig_t x =  it->first ;
        vector<edge_t> adjx = it->second;
        for(edge_t e: adjx){
            unitig_t walk = oldToNew[e.toNode].finalWalkId;
            oldnode[walk] =e.toNode;
            indegree[walk] = make_pair(indegree[walk].first, indegree[walk].second+1);
        }
    }
    
    deque<unitig_t> dq;
    stack<unitig_t> putLast;

    bool SCCORDER = true;
    if(SCCORDER){
        //cout<<"scc: "<<endl;
        queue<unitig_t> topoorder = printSCCs();
        while(!topoorder.empty()){
            unitig_t jj =topoorder.front();
            topoorder.pop();
            dq.push_front(jj);
        }
    }

    delete g;
    

    while(!dq.empty()){
        unitig_t qtop = dq.front();
        dq.pop_front();
        if(visited[oldToNew[qtop].finalWalkId] == 'w' ){
            //visited[oldToNew[qtop].finalWalkId] = 'g';
            stak.push(qtop);
            // Push the current source node.
            orderOfUnitigs.push(oldToNew[qtop].finalWalkId);

            while (!stak.empty())
            {
                unitig_t uid = stak.top();
                stak.pop();

                if(visited[oldToNew[uid].finalWalkId] == 'w'){
                    visited[oldToNew[uid].finalWalkId] = 'g';
                    if(parent[uid]!=-1){
                        edge_t e = edmap[uid];
                        unitig_t alluid = parent[uid];
                        absorbGraphCycleRemoved[parent[uid]].push(e);
                        absorbed[oldToNew[e.toNode].finalWalkId] = true;
                        if(e.left == nodeSign[alluid] && e.right == nodeSign[e.toNode] )
                            absorbedCategory[e.toNode] = '1';
                        if(e.left == nodeSign[alluid] && e.right != nodeSign[e.toNode] )
                            absorbedCategory[e.toNode] = '2';
                        if(e.left != nodeSign[alluid] && e.right != nodeSign[e.toNode] )
                            absorbedCategory[e.toNode] = '3';
                        if(e.left != nodeSign[alluid] && e.right == nodeSign[e.toNode] )
                            absorbedCategory[e.toNode] = '4';
                    }

                    vector<unitig_t> uidsNeighbors = getAllUidsInWalk( oldToNew[uid].finalWalkId);
                    for(unitig_t alluid:uidsNeighbors){
                        vector<edge_t> adjv = absorbGraph[alluid];
                        for(edge_t e : adjv){
                            unitig_t i = e.toNode;
                            if (visited[oldToNew[i].finalWalkId] == 'g'){
                                //removed edge
                                //edmap[e.toNode] = e;
                                //parent[e.toNode] = alluid;
                            }else if (visited[oldToNew[i].finalWalkId] == 'w'){
                                //cout<<"adding edge: "<<alluid<<"->"<<e.toNode<<"["<<oldToNew[alluid].finalWalkId<<","<<oldToNew[e.toNode].finalWalkId<<"]"<<"scc:"<<oldToNew[alluid].sccid<<","<<oldToNew[e.toNode].sccid<<endl;
                                //visited[oldToNew[alluid].finalWalkId] = 'g';
                                edmap[e.toNode] = e;
                                parent[e.toNode] = alluid;
                                stak.push(e.toNode);
                            }
                        }
                    }
                }

                visited[oldToNew[uid].finalWalkId]  = 'b';
            }
            //reservedStringSize.push(stringSize);
        }
    }
    delete[] visited;
    delete[] parent;
    //absorbGraph.clear();
    map<unitig_t, vector<edge_t> >().swap(absorbGraph);
    map<unitig_t, edge_t>().swap(edmap);
    //postorder_master();
}




void AbsorbGraph::printFormattedPattern(unitig_t uid, char preOrSuf, ofstream &FOUT){
    
    if(uid==-1){
        //FOUT<<(preOrSuf);
    }else{
        if(preOrSuf == 'p') {
            cp << uid <<endl;
        }
        if(preOrSuf == 'P') cP << uid <<endl;
        if(preOrSuf == 's') cs << uid <<endl;
        if(preOrSuf == 'S') cS << uid <<endl;
        if(preOrSuf == 'x') cx << uid <<endl;
        if(preOrSuf == 'f') {
            cp << uid <<endl;
            cP << uid <<endl;
        }
        //FOUT<<(preOrSuf) << ":"  << (uid) <<  ":" ;
        
    }
//    if(preOrSuf=='+'){
//        FOUT<<'a';
//    }else if(preOrSuf=='-'){
//        FOUT<<'c';
//    }else if(preOrSuf=='['){
//        FOUT<<'g';
//    }else if(preOrSuf==']'){
//        FOUT<<'t';
//    }else{
//        FOUT<<(preOrSuf);
//    }
    FOUT<<(preOrSuf);


    if(DDEBUG){
        std::ofstream debugFile;

        debugFile.open("debug.txt", std::ios_base::app); // append instead of overwrite
        if(uid!=-1){
            debugFile << uid;
        }
        debugFile<<(preOrSuf);
        debugFile.close();
    }
}

void AbsorbGraph::splitToFourPartNodeSign(){
    //splitToFourPartNodeSign
    
    ifstream unitigFile(param.UNITIG_FILE);
    
    unitig_t uid = 0;
    ofstream sixColFile("sixColFile.txt");
    string tp;
    while(getline(unitigFile, tp)){ //read data from file object and put it into string.
        getline(unitigFile, tp);
        if(nodeSign[uid] == false){
            tp = reverseComplement(tp);
        }
        
        string splitx = "";
        if(tp.length()>=2*(K-1)){
            splitx = splitX(tp, K);
        }
        
        sixColFile<<uid<<" "<<pref(tp, K)<<" "<<cutPref(tp, K)<<" "<<suf(tp, K)<<" "<<cutSuf(tp, K)<<" "<<splitx<<endl;
        uid++;
    }
    unitigFile.close();
    sixColFile.close();

    
    if(system("mkdir -p tmp/") != 0) exit(3);

    if(system("export TMPDIR=$PWD/tmp/") != 0) exit(3);
    //sort the mega file: prepare for join
    if(system("sort -t' ' -k1b,1 -o sixColFile.sorted sixColFile.txt")  != 0) exit(3);
    
    //sort the prefix file
    if(system("awk \'{print $0 \" \" NR-1}\' preNumFile.txt | sort -t' ' -k1b,1 -o preNumFile.sorted; join -t' ' -o 0,1.2,2.2 preNumFile.sorted sixColFile.sorted | sort -t' ' -n -k2 -o preNumFile.txt; cut -d' ' -f3 preNumFile.txt > preNumFile.sorted") != 0) exit(3);
    if(true){
        if(system("rm -rf preNumFile.txt") != 0) exit(3);
    }
    
    if(system("awk \'{print $0 \" \" NR-1}\' cutpreNumFile.txt | sort -t' ' -k1b,1 -o cutpreNumFile.sorted; join -t' ' -o 0,1.2,2.3 cutpreNumFile.sorted sixColFile.sorted | sort -t' ' -n -k2 -o cutpreNumFile.txt; cut -d' ' -f3 cutpreNumFile.txt > cutpreNumFile.sorted") != 0) exit(3);
    if(true){
        if(system("rm -rf cutpreNumFile.txt") != 0) exit(3);
    }

    if(system("awk \'{print $0 \" \" NR-1}\' sufNumFile.txt | sort -t' ' -k1b,1 -o sufNumFile.sorted; join -t' ' -o 0,1.2,2.4 sufNumFile.sorted sixColFile.sorted | sort -t' ' -n -k2 -o sufNumFile.txt; cut -d' ' -f3 sufNumFile.txt > sufNumFile.sorted; rm -rf sufNumFile.txt") != 0) exit(3);
    
    if(system("awk \'{print $0 \" \" NR-1}\' cutsufNumFile.txt | sort -t' ' -k1b,1 -o cutsufNumFile.sorted; join  -t' ' -o 0,1.2,2.5 cutsufNumFile.sorted sixColFile.sorted | sort -t' ' -n -k2 -o cutsufNumFile.txt; cut -d' ' -f3 cutsufNumFile.txt > cutsufNumFile.sorted; rm -rf cutsufNumFile.txt") != 0) exit(3);


    if(system("awk \'{print $0 \" \" NR-1}\' xNumFile.txt | sort -t' ' -k1b,1 -o xNumFile.sorted; join -t' ' -o 0,1.2,2.6 xNumFile.sorted sixColFile.sorted | sort -t' ' -n -k2 -o xNumFile.txt; cut -d' ' -f3 xNumFile.txt > xNumFile.sorted; rm -rf xNumFile.txt") != 0) exit(3);

    
    ifstream cpI("preNumFile.sorted");
    ifstream cPI("cutpreNumFile.sorted");
    ifstream csI("sufNumFile.sorted");
    ifstream cSI("cutsufNumFile.sorted");
    ifstream cxI("xNumFile.sorted");
    ofstream finalESS("final.ess");
    
    char ch;
    ifstream fin("intESSFile.txt");
    
    while (fin >> noskipws >> ch) {
        string line;
        if(ch=='p'){
            std::getline(cpI, line);
            //line.erase(line.find_last_not_of("\t\n\v\f\r ") + 1);
            finalESS<<line;
        }else if(ch=='P'){
            std::getline(cPI, line);
            //line.erase(line.find_last_not_of("\t\n\v\f\r ") + 1);
            finalESS<<line;
        }else if(ch=='s'){
            std::getline(csI, line);
            //line.erase(line.find_last_not_of("\t\n\v\f\r ") + 1);
            finalESS<<line;
        }else if(ch=='S'){
            std::getline(cSI, line);
            //line.erase(line.find_last_not_of("\t\n\v\f\r ") + 1);
            finalESS<<line;
        }else if(ch=='x'){
            std::getline(cxI, line);
            //line.erase(line.find_last_not_of("\t\n\v\f\r ") + 1);
            finalESS<<line;
        }else if(ch=='f'){
            std::getline(cpI, line);
            finalESS<<line;
            std::getline(cPI, line);
            //line.erase(line.find_last_not_of("\t\n\v\f\r ") + 1);
            finalESS<<line;
        }else{
            finalESS<<ch;
        }
    }
    
    
    
    
    cpI.close();
    cPI.close();
    csI.close();
    cSI.close();
    cxI.close();
    fin.close();
    finalESS.close();
    
    //if(system("cat final.ess > fa.ess")!=0) exit(3);
    
    if(false) string cmdn = "sed -e 's/[ACGT]\\{"+to_string(K-1)+"\\}r//g' final.ess > fa.ess";
    string cmdn = "sed -e 's/[ACGT]\\{"+to_string(K-1)+"\\}r//g' final.ess > " + param.OUTPUT_FILENAME;
    
    
    if(system(cmdn.c_str())!=0) exit(3);
    
    
    if(system("rm -rf cutpreNumFile.sorted cutsufNumFile.sorted intESSFile.txt final.ess preNumFile.sorted sufNumFile.sorted xNumFile.sorted") != 0) exit(3);
    if(!DDEBUG) {
        if(system("rm -rf tmp/  sixColFile.sorted sixColFile.txt ") != 0) exit(3);
    }

}



void AbsorbGraph::iterSpellEfficient(unitig_t startWalkIndex2, vector<char>& color, ofstream &tipNoStrFile)
{
    stack<unitig_t> recurStak;//startWalkIndex
    recurStak.push(startWalkIndex2);
    
    while(!recurStak.empty()){
        unitig_t currSorterIndex = recurStak.top();
        recurStak.pop();
        
        bool isThisAbsorbedWalk = false;
        //string unitigString = "";
        
        
        while(true){
            assert(currSorterIndex<sorter.size());
//            if (isItAPrintedWalk[get<1>(sorter[currSorterIndex])]){
//                return;
//            }
            
            threetuple n = sorter[currSorterIndex];
            unitig_t finalWalkId = get<1>(n);
            unitig_t uid = get<0>(n);
            
            if(color[currSorterIndex]=='w' or color[currSorterIndex]=='g'){
                recurStak.push(currSorterIndex);
            }
            
            //if(nodeSign[uid] == false){
            //    unitigString =  reverseComplement(unitigs.at(uid).sequence);
            //}else{
            //    unitigString =  (unitigs.at(uid).sequence);
            //}
            
            stack<edge_t> stType12;
            stack<edge_t> stType34;
            if(absorbGraphCycleRemoved[uid].size() > 0){         /*populate two types of stacks*/
                stack<edge_t> st = absorbGraphCycleRemoved[uid];
                while(!st.empty()){
                    edge_t st_top = st.top();
                    if(absorbedCategory[st_top.toNode]=='3' or absorbedCategory[st_top.toNode]=='4'  ){
                        stType34.push(st_top);
                    }else if(absorbedCategory[st_top.toNode]=='1' or absorbedCategory[st_top.toNode]=='2' ){
                        stType12.push(st_top);
                    }else{
                        assert(false);
                    }
                    st.pop();
                }
                
            }
            
            
            //walkstarting ####
            if( isItWalkStarting(uid)){
                if(absorbedCategory[uid]=='0'){ //not absorbed
                    
                    
                    //earlyAbsorb-NEW
                    if(color[currSorterIndex]=='w' && absorbed[finalWalkId]){
                        isThisAbsorbedWalk=true;
                        //tipFile<<"[";
                        printFormattedPattern(-1, NONDNA_START, tipNoStrFile);
                    }
                    
                    
                    if(unitigs.at(uid).ln<2*(K-1)){
                        if(color[currSorterIndex]=='w'){
                            //tipFile<<unitigString;
                            printFormattedPattern(uid, 'f', tipNoStrFile);
                        }
                        
                    }else{
                        if(color[currSorterIndex]=='w'){
                            //tipFile<<splitA(unitigString, K);
                            printFormattedPattern(uid, 'p', tipNoStrFile);
                            
                            while(!stType34.empty()){
                                recurStak.push(sorterIndexMap[oldToNew[stType34.top().toNode].finalWalkId]);
                                stType34.pop();
                            }
                        }
                        
                        if(color[currSorterIndex]=='g'){
                            //tipFile<<splitX(unitigString, K);
                            //tipFile<<splitB(unitigString, K);
                            printFormattedPattern(uid, 'P', tipNoStrFile);
                        }
                    }
                }else{
                    if(color[currSorterIndex]=='w'){
                        isThisAbsorbedWalk=true;
                        
                        //tipFile<<"[";
                        printFormattedPattern(-1, NONDNA_START, tipNoStrFile);
                    }
                    
                    if(unitigs.at(uid).ln>=2*(K-1)){
                        string sign = (absorbedCategory[uid]=='2' or absorbedCategory[uid]=='4')?NONDNA_MINUS:NONDNA_PLUS;
                        if(absorbedCategory[uid]=='2' or absorbedCategory[uid]=='3'){
                            //string apart = cutSuf(unitigString, K);
                            if(color[currSorterIndex]=='w') {
                                //tipFile<<pref(unitigString, K);
                                printFormattedPattern(uid, 'p', tipNoStrFile);
                            }
                            
                            if(color[currSorterIndex]=='w'){
                                while(!stType34.empty()){
                                    recurStak.push(sorterIndexMap[oldToNew[stType34.top().toNode].finalWalkId]);
                                    stType34.pop();
                                }
                            }
                            if(color[currSorterIndex]=='g') {
                                //tipFile<<cutPref(apart, K);
                                //tipFile<<sign;
                                printFormattedPattern(uid,  'x', tipNoStrFile);
                                printFormattedPattern(-1,  sign[0], tipNoStrFile);
                            }
                            
                            
                        }else{
                            if(color[currSorterIndex]=='w') {
                                //tipFile<<sign;
                                printFormattedPattern(-1,  sign[0], tipNoStrFile);
                                
                                while(!stType34.empty()){
                                    recurStak.push(sorterIndexMap[oldToNew[stType34.top().toNode].finalWalkId]);
                                    stType34.pop();
                                }
                            }
                            
                            if(color[currSorterIndex]=='g') {
                                //tipFile<<splitX(unitigString, K);
                                //tipFile<<splitB(unitigString, K);
                                printFormattedPattern(uid,  'P', tipNoStrFile);
                            }
                            
                        }
                    }else{
                        string sign = (absorbedCategory[uid]=='2' or absorbedCategory[uid]=='4')?NONDNA_MINUS:NONDNA_PLUS;
                        if(absorbedCategory[uid]=='2' or absorbedCategory[uid]=='3'){
                            if(color[currSorterIndex]=='w') {
                                //tipFile<<cutSuf(unitigString, K);
                                //tipFile<<sign;
                                printFormattedPattern(uid, 'S', tipNoStrFile);
                                printFormattedPattern(-1,  sign[0], tipNoStrFile);
                            }
                        }else{
                            if(color[currSorterIndex]=='w') {
                                //tipFile<<sign;
                                //tipFile<<splitX(unitigString, K);
                                //tipFile<<splitB(unitigString, K);
                                printFormattedPattern(-1, sign[0], tipNoStrFile);
                                printFormattedPattern(uid, 'P', tipNoStrFile);
                            }
                        }
                    }
                }
                if(color[currSorterIndex]=='g'){
                    while(!stType12.empty()){
                        recurStak.push(sorterIndexMap[oldToNew[stType12.top().toNode].finalWalkId]);
                        stType12.pop();
                    }
                }
            }else{ //not walk starting
                if(absorbedCategory[uid]=='0'){
                    
                    if(color[currSorterIndex]=='w'){
                        while(!stType34.empty()){
                            recurStak.push(sorterIndexMap[oldToNew[stType34.top().toNode].finalWalkId]);
                            stType34.pop();
                        }
                    }
                    
                    if(color[currSorterIndex]=='g'){
                        //tipFile<<splitX(unitigString, K);
                        //tipFile<<splitB(unitigString, K);
                        printFormattedPattern(uid, 'P', tipNoStrFile);
                        
                    }
                    
                    if(color[currSorterIndex]=='g'){
                        while(!stType12.empty()){
                            recurStak.push(sorterIndexMap[oldToNew[stType12.top().toNode].finalWalkId]);
                            stType12.pop();
                        }
                    }
                }
                //earlyAbsorb-NEW
                if(absorbedCategory[uid]!='0'){
                    assert(absorbed[oldToNew[uid].finalWalkId]==true);
                    isThisAbsorbedWalk=true;
                    assert(stType34.empty());
                    assert(stType12.empty());

                    if(color[currSorterIndex]=='w') {
                        if(absorbedCategory[uid]=='1' or absorbedCategory[uid]=='4' ){
                            string signs;
                            if(absorbedCategory[uid]=='1') signs=NONDNA_PLUS;
                            else if(absorbedCategory[uid]=='4') signs=NONDNA_MINUS;
                            
                            printFormattedPattern(-1, 'r', tipNoStrFile);
                            printFormattedPattern(-1, signs[0], tipNoStrFile);
                            printFormattedPattern(uid, 'P', tipNoStrFile);
                        }

                        if(absorbedCategory[uid]=='2' or absorbedCategory[uid]=='3' ){
                            string signs;
                            if(absorbedCategory[uid]=='3') signs=NONDNA_PLUS;
                            else if(absorbedCategory[uid]=='2') signs=NONDNA_MINUS;
                            
                            printFormattedPattern(-1, 'r', tipNoStrFile);
                            printFormattedPattern(uid, 'S', tipNoStrFile);
                            printFormattedPattern(-1, signs[0], tipNoStrFile);
                        }
                    }
                }
            }
            
            if(color[currSorterIndex]=='g'){
                color[currSorterIndex] = 'b';
                break;
            }else if(color[currSorterIndex]=='w'){
                color[currSorterIndex] = 'g';
                break;
            }//else{
                //assert(false);
            //}
            
            if(currSorterIndex+1 == sorter.size() or get<1>(sorter[currSorterIndex+1]) != finalWalkId){
                if(color[currSorterIndex]=='b' && absorbed[finalWalkId] == true) {
                    //tipFile<<"]";
                    printFormattedPattern(-1,  NONDNA_END, tipNoStrFile);
                }
                //isItAPrintedWalk[finalWalkId] = true;
                if(color[currSorterIndex] == 'b') break;
            }
            if(color[currSorterIndex] == 'b') currSorterIndex++;
        }
    }
}


void AbsorbGraph::tipAbsorbedOutputter(){
    //tipFile.open(ofileTipOutput);
    cp.open("preNumFile.txt");
    cP.open("cutpreNumFile.txt");
    cs.open("sufNumFile.txt");
    cS.open("cutsufNumFile.txt");
    cx.open("xNumFile.txt");


    ofstream tipNoStrFile;
    tipNoStrFile.open("intESSFile.txt");

    ofstream debugFile;
    if(DDEBUG){
        if(system("rm -rf debug.txt")!=0)  exit(3);
        debugFile.open("debug.txt", std::ios_base::app); // append instead of overwrite
    }
    vector<char> color(sorter.size(), 'w');

//    for(int i = 0; i<countNewNode; i++){
//        isItAPrintedWalk[i] = false;
//    }
    int header_count = 0;

    while(!orderOfUnitigs.empty()){
        unitig_t it = sorterIndexMap[orderOfUnitigs.front()];

        if(DBGFLAG==PRINTER){
            cout<<"order: "<<orderOfUnitigs.front()<<endl;
        }
        orderOfUnitigs.pop();

        //tipFile<<">\n";
        if(header_count==0){
            tipNoStrFile<<">2.0_"<<K<<"_"<<"0"<<endl; //1 for tip
            header_count++;
        }else{
            tipNoStrFile<<">\n";
        }
        
        if(DDEBUG) debugFile<<">\n";

        //iterSpellTested(it, depth, K, color, 0);
        unitig_t & startWalkIndex2 = it;
        iterSpellEfficient( startWalkIndex2,  color, tipNoStrFile);

        //walkString = constructedStrings[get<1>(sorter[it])];

        stat.V_ess++;
        //tipFile<<"\n";
        tipNoStrFile<<"\n";
        if(DDEBUG) debugFile<<"\n";
    }


    cp.close();
    cs.close();
    cS.close();
    cP.close();
    cx.close();
    tipNoStrFile.close();
    if(DDEBUG) debugFile.close();
    //tipFile.close();

    splitToFourPartNodeSign();
}


void AbsorbGraph::makeGraphDotAbsorb(map<unitig_t, vector<edge_t> > adjList){
    FILE * fp;
    fp = fopen ("/Users/Sherlock/dot-visualize/graph.gv", "w+");
    fprintf(fp, "digraph d {\n");
    set<unitig_t> vertices;
    for (std::map<unitig_t, vector<edge_t> >::iterator it=adjList.begin(); it!=adjList.end(); ++it){
        unitig_t x =  it->first ;
        vector<edge_t> adjX = it->second;
        for(edge_t ex: adjX){
            vertices.insert(oldToNew[x].finalWalkId);
            vertices.insert(oldToNew[ex.toNode].finalWalkId);
            fprintf(fp, "%d -> %d[taillabel=\"%d\", headlabel=\"%d\"]\n", oldToNew[x].finalWalkId, oldToNew[ex.toNode].finalWalkId, ex.left, !ex.right);
            cout<<oldToNew[x].finalWalkId<<"->"<<oldToNew[ex.toNode].finalWalkId<<endl;
        }
    }
    for(unitig_t i = 0 ; i<countNewNode; i++){
        if(!obsoleteWalkId[i] && vertices.count(i)==0 ){
            vertices.insert(i);
        }
    }
    for(unitig_t x: vertices){
        if(false){
            fprintf(fp, "%d [label=\"%d\", color=\"red\"]\n", x, x);
        }else{
            fprintf(fp, "%d [label=\"%d\"]\n", x, x);
        }

    }

    fprintf(fp, "}\n");
    fclose(fp);
}


void AbsorbGraph::absorptionManager() {
    
    /*initialize block*/
    //this->sorter = sorter;

    g = new SCCGraph(countNewNode);
    absorbedCategory = new char[V_bcalm];
    absorbed = new bool[countNewNode];
    //isItAPrintedWalk = new bool[countNewNode];
    
    for(unitig_t i=0; i< V_bcalm; i++){
        absorbedCategory[i] = '0';
    }

    for(unitig_t i=0; i<countNewNode; i++){
        //isItAPrintedWalk[i]=false;
        absorbed[i] = false;
    }
    
    /* start different steps of ESS*/
    sorterIndexAndAbsorbGraphMaker();//sorter, sorterIndexMap, absorbGraph, absorbedCategory
    //makeGraphDotAbsorb(absorbGraph);

    if(param.VERBOSE_MODE) cout<<"[4] Removing cycles from absorption graph (forest construction step)..."<<endl;
    removeCycleFromAbsorbGraph();//sorter,  sorterIndexMap, absorbGraph, absorbGraphCycleRemoved,  orderOfUnitigs,  absorbedCategory, last two are output
    if(param.VERBOSE_MODE) cout<<"Done!"<<endl;

    if(param.VERBOSE_MODE) cout<<"[5] Spelling paths and dumping them to disk...";
    tipAbsorbedOutputter(); //sorter, sorterIndexMap, absorbGraphCycleRemoved, orderOfUnitigs, absorbedCategory
    if(param.VERBOSE_MODE) cout<<"Done!"<<endl;

}

SCCGraph::SCCGraph(unitig_t V)
{
    this->V = V;
    adj = new vector<unitig_t>[V];
}
SCCGraph::SCCGraph()
{
}

void SCCGraph::addEdge(unitig_t v, unitig_t w)
{
    adj[v].push_back(w); // Add w to vs list.
}

queue<unitig_t> AbsorbGraph::printSCCs()
{
    unitig_t countSCC = 0;
    map<unitig_t, unitig_t> vToMetagraphV;
    map<unitig_t, set<unitig_t> > adjSCC;
    map<unitig_t, set<unitig_t> > sccIdToWalks;
        
    g->findTarjanSCC(countSCC, vToMetagraphV, obsoleteWalkId, sccIdToWalks);
    //countSCC
    
    queue<unitig_t> uidorder;
    if(1==1){
        unitig_t* outdeg = new unitig_t[countSCC];
        for(unitig_t u = 0 ; u<countSCC; u++){
            outdeg[u] = 0;
        }
        for(unitig_t u = 0 ; u<g->V; u++){
            for (auto i = g->adj[u].begin(); i != g->adj[u].end(); ++i)
            {
                unitig_t v = *i;
                //cout<<vToMetagraphV[v]<<endl;
                if(vToMetagraphV[v] != vToMetagraphV[u]){
                    adjSCC[vToMetagraphV[v]].insert(vToMetagraphV[u]); //reverse graph
                    //cout<<"scc edge: "<<vToMetagraphV[u]<<"->"<<vToMetagraphV[v]<<endl;
                    outdeg[vToMetagraphV[u]]++;
                }

            }
        }
        unitig_t lowerbound = 0;
        queue<unitig_t> later;

        for(unitig_t sccid = 0 ; sccid<countSCC; sccid++){

            unitig_t indegree = adjSCC[sccid].size();

            //cout<<sccid<<" " << indegree<< " ,out=" << outdeg[sccid]<<endl;
            if(indegree==0){   //these are the sources
                set<unitig_t> walks = sccIdToWalks[sccid];
                //cout<<"walk in scc "<<sccid<<":";
                for(unitig_t ww: walks){
                    //cout<<ww<<" ";
                    vector<unitig_t> uidsNeighbors = this->getAllUidsInWalk(ww);
                    for(unitig_t i = 0; i<uidsNeighbors.size(); i++){
                        // uidorder.push(uidsNeighbors[i]);
                        oldToNew[uidsNeighbors[i]].sccid = sccid;
                    }
                    if(uidsNeighbors.size()!=0){
                        //uidorder.push(uidsNeighbors[0]);
                    }
                    //break;
                }
                //cout<<endl;
                for(unitig_t ww: walks){
                    assert(!obsoleteWalkId[ww]);
                    if(!obsoleteWalkId[ww]){
                        vector<unitig_t> uidsNeighbors = getAllUidsInWalk(ww);
                        for(unitig_t i = 0; i<uidsNeighbors.size(); i++){
                            uidorder.push(uidsNeighbors[i]);
                            break;
                        }
                        //break;
                    }

                }


                lowerbound++;
            }else{
                set<unitig_t> walks = sccIdToWalks[sccid];
                for(unitig_t ww: walks){
                    vector<unitig_t> uidsNeighbors = getAllUidsInWalk(ww);
                    for(unitig_t i = 0; i<uidsNeighbors.size(); i++){
                        later.push(uidsNeighbors[i]);
                        oldToNew[uidsNeighbors[i]].sccid = sccid;
                    }
                }

            }

        }
//        while(!uidorder.empty()){
//            int t =uidorder.front();
//            later.push(t);
//            uidorder.pop();
//        }
//        uidorder = later;
        map<unitig_t, unitig_t> checkdup;


        if(param.VERBOSE_MODE) cout<<"Number of strings in ESS-Compress representation: "<<lowerbound<<endl;
        stat.absorbGraphNumCC_endAbosrb = lowerbound;
        delete[] outdeg;
    }
    return uidorder;
}
